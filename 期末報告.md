## 閱讀內容(有參考但無直接使用的內容):
[如何設計電腦 -- 還有讓電腦變快的那些方法](https://www.slideshare.net/ccckmit/ss-85466673)<br>
[x86 程式](https://gitlab.com/ccc110/co/-/tree/master/x86/01-asm)<br>
[前瞻加法器(CLA)設計之數位乘法器](http://nfudee.nfu.edu.tw/ezfiles/43/1043/img/326/dc7.pdf)<br>
[什么是RISC－V架构，对比x86、ARM有什么优势？](https://ee.ofweek.com/2021-04/ART-11000-2818-30492386.html)<br>
[BSD協議](https://baike.baidu.hk/item/BSD%E5%8D%94%E8%AD%B0/8013651)<br>
[RISC-V & x86(維基)](https://zh.wikipedia.org/wiki)

## 如何設計電腦 -- 還有讓電腦變快的那些方法
<pre>
<li>nand2tetris:
      題目做完了，主要困難反而不是在邏輯，而是清楚明白它要的結果為何。
      到APU以後的題目，.hdl檔上的註解已經是在考驗我的英文程度了，有的多花些時間能看懂，看不懂就從答案推回去了。
      
<li>乘法器可用加法器+移位運算組成:
      這部分剛看有點矇，也看不懂VerilogHDL硬體語言，隨即想到其為二進位就通了，畫面大概是:
          0101 = 5
         x1010 = 10
         ------
         0101
      +0101
      ---------
        110010 = 50
      相當於根據下項1的位置移動上項再相加。
      
<li>除法器:
      10101(21) / 10(2) => 1010(10)...1
                    10101
                   -10    =>1000---┐
                    ------         |
                      101          V
                     -10  =>10 + 1000 = 1010 = 10
                    ------
                        1
 
<li>浮點數乘法較加法簡單:
      以之前計算機概論學到的科學記號的儲存方式，乘法只要前頭數字相乘，後頭指數相乘就行。
      加法則需要根據後頭的指數對齊位數才能相加。

<li>前瞻進位加法器:
      看了圖，爬了文，不確定自己的理解是否正確。
      在我看來，相比原來的全加器，本是接A Xor B的部分，改接A or B，用到的nand閘較少。
      但僅是這樣應該不至於給名子，頂多是全加器2.0。
      我對它結構還是不太了解。
      
<li>CPU加速技巧:
      快取: 使用容量小但效率高的記憶體減少運算時間。
      程式區域性: 由於[i][j]在[i]區域內，先改變[j]的相當於執行完一區[i]再換區，
                  先改[i]的則是在不同[i]區域間跳來跳去，較易出錯。
      平行運算: 以邊緣觸發正反器隔絕不同功能執行區域，使其能同時運作。
      (pipeline)(跳躍指令會造成空執行產生，影響效率，是個加快運作的改進方向)
      多核心: 多個類似小型CPU的結構同時運作，提高執行效率。
      (記憶體一次只能由一個核心存取，是個改進方向，多幾個記憶體之類的)
      GPU: 具多個浮點數乘法及加法的運算單元，較適合處理螢幕繪圖。
</pre>

## x86處理器 及 RISC-V處理器
看得懂的部分是
:
x86較舊但有舊時代遺產的問題；RISC-V較新，設計較貼近現在及不久的將來，且使用BSD協議，但時日尚短，產業鏈未完善。

x86組合語言的部分，加上註解雖不至於完全看不懂，不過陌生的指令看得很痛苦。
