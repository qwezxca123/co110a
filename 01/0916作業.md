## Not
```
CHIP Not {
    IN in;
    OUT out;

    PARTS:
    // Put your code here:
    Nand(a=in, b=in, out=out);
}
```
Nand 11為0,00為1,直接用就好

## And
```
CHIP And {
    IN a, b;
    OUT out;

    PARTS:
    // Put your code here:
    Nand(a=a,b=b,out=ab);
    Not(in=ab,out=out);
}
```
And為Nand反邏輯,反轉Nand結果即可

## Or
```
CHIP Or {
    IN a, b;
    OUT out;

    PARTS:
    // Put your code here:
    Not(in=a,out=na);
    Not(in=b,out=nb);
    Nand(a=na,b=nb,out=out);
}
```
Nand:    Or:
1 1 0    1 1 1
1 0 1    1 0 1
0 1 1    0 1 1
0 0 1    0 0 0

差別於11,00結果相反
在值進入Nand之前加上Not使11->00;00->11即可
10與01結果相同不用考慮

## Xor(互斥)
```
CHIP Xor {
    IN a, b;
    OUT out;

    PARTS:
    // Put your code here;
    Nand(a=a,b=b,out=oa);
    Or(a=a,b=b,out=oo);
    And(a=oa,b=oo,out=out);
}
```
Nand:    Xor:
1 1 0    1 1 0
1 0 1    1 0 1
0 1 1    0 1 1
0 0 1    0 0 0

差別在00結果
Nand後若為0,or出來也是0
若為1則需要檢測是否為00,若是結果為0
推知最後可使用And並連接Nand及00檢測結果
00檢測適合用or:只有00為0,導入And後令結果為0

## Mux!

```
CHIP Mux {
    IN a, b, sel;
    OUT out;

    PARTS:
    // Put your code here:
    Not(in=sel,out=ns);
    And(a=a,b=ns,out=ans);
    And(a=sel,b=b,out=sb);
    Or(a=ans,b=sb,out=out);
}
```
## DMux
```
CHIP DMux {
    IN in, sel;
    OUT a, b;

    PARTS:
    // Put your code here:
    Not(in=sel,out=ns);
    And(a=in,b=ns,out=a);
    And(a=in,b=sel,out=b);
}
```
